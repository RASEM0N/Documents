Архитектура программного обеспечения (англ. software architecture) — совокупность важнейших решений об организации программной системы. Архитектура включает:

- выбор структурных элементов и их интерфейсов, с помощью которых составлена система, а также их поведения в рамках сотрудничества структурных элементов;
- соединение выбранных элементов структуры и поведения во всё более крупные системы;
- архитектурный стиль, который направляет всю организацию — все элементы, их интерфейсы, их сотрудничество и их соединение.

_К вопросам архитектуры так же относятся вопросы технологии разработки и функциональные роли внутри команды. Agile – это тоже часть архитектуры._

**Зачем все это надо**  
- Требования и повышение требований к продукту
- Растущие темпы разработки;
- Увеличивающаяся сложность процесса разработки;
- Необходимость интеграции всего со всем (готовность к интеграции).

**Архитектура помогает**
- управлять монолитностью на всех уровнях;
- локализовать и изолировать проблемные места (эффективный root cause analysis);
- блокирует «эффект домино»;
- управлять скоростью разработки;
- наращивать команду;
- прогнозировать развитие системы;
- принципы архитектуры помогают принимать решения.

##### Признаки плохой архитектуры
- полный игнор вопросов архитектуры;
- неформализованные требования и ограничения;
- отсутствие метрик качества и контроля;
- приоритет наращивания функциональности;
- широкая вариативность повторного использования компонент, переусложненные компоненты с частичным использованием функциональности;
- недостаток механизмов управления командой;
- большое количество «ручного» труда, отсутствие сценариев автоматизации;
- не фиксируется технический долг и он обычно уже большой;
- разработчики плохо представляют что такое архитектура, не умеют мыслить в отрыве от когда, не понимают абстракций, имеют узкую квалификацию;
- отсутствие тестирования, рефакторинга и прочих техник;
- проблемы при генерации и проверке гипотез - первое решение принимается как правильное

##### Порядок улучшения
- уменьшение технического долга до приемлемого:
  - актуализация «внешних» ресурсов;
  - первоначальный рефакторинг очистка мусора;
  - фиксация изменений и требований к проекту;
- определение технологии разработки:
  - определение зон ответственности;
  - выделение команд;
  - определение способа взаимодействия внутри команды;
  - рефакторинг, тестирование и культура разработки;
- специфицирование продукта:
  - явное выделение требований и составление спецификаций;
  - определение границ;
  - определение вектора развития;
- выстраивание процессов
  - инциденты
  - проблемы
  - конфигурация
  - исследования (генерация и проверка гипотез)
- определить вид архитектуры;
- определить основные принципы и ответственность компонентов архитектуры;
- изоляция и определение промежуточных состояний;
- определение конечного прототипа архитектуры;
- моделирование - модель отражает упрощенное представление реальной бизнес задачи и служит для выстраивания аспектов системы;
- валидация - проверка технических и логических моментов на корректность.

_Эмпирическое наблюдение: время на «оздоровление» проекта пропорционально времени «загнивания»._  
_роцесс должен быть итеративным, а не линейным, несмотря на то, что пункты перечислены последовательно, объемы нужно определять исходя из фактических реалий, постепенно их уточняя._

##### Как понять какая архитектура ?
Обычный процесс это постепенная детализация требований к проекту:  
`спецификация – архитектура – логика – структура – код`

Для определения архитектуры проекта необходимо выполнить обратный процесс:
- определить модульность на уровне структуры кода (файлы/каталоги);
- выделить модульность на уровне логики (композиция структуры);
- обезличить логику, выделив только основные модули и компоненты.

Отдельно определяется архитектурная композиция на уровне приложения и архитектурная композиция на уровне системы.  
На каждом уровне может быть «инфраструктурный слой» и средства контроля и мониторинга, они анализируется отдельно, если требуется.  
Процесс не обязательно выполнять полностью, обычно требуется понять только силу монолитности проекта, чтобы определить его способность принимать изменения.