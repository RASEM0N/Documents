# Эволюционная архитектура

это такой подход к построению архитектуры, который ставит перед собой цель `двигаться вперед небольшими шагами, сохраняя темп разработки`. 

Способность программного продукта развиваться с течением времени не требуя при этом полного перестроения приложения.

Эволюционность напрямую зависит от организации процесса разработки и невозможна без организации соответствующего процесса разработки.

_На уровне кода и приложения, т.е. на уровне обычных разработчиков проблемы создают архитектурные, методологические и организационные антипаттерны._

## Антипаттерны уровня архитектуры приложения и кода
- Большой комок грязи;
- God object;
- Раздувание интерфейса (Interface bloat) - разработка интерфейса очень мощным и очень сложным для реализации (не используются большинство методов интерфейса);
- Перестыковка - внедрения ненужной зависимостей;
- Гонка (Race condition) - непредвиденные возможности наступления событий в порядке, отличном от ожидаемого;
- Мышиная возня - неоправданное создание множества мелких и абстрактных классов.

## Антипаттерны уровня кода (основная боль программистов)
- Copy and Past;
- Дефакторинг - уничтожения функциональности и замены её документацией или организационными действиями;
- Золотой молоток - уверенность в том, что любимое решение универсально применимо («когда в руках молоток, все проблемы кажутся гвоздями»);
- Программирование методом подбора (Programming by permutation) - подход к разработке программного обеспечения небольшими рандомными изменениями;
- Два стула - нынесение новой функциональности в отдельное приложение вместо расширения уже имеющегося.

## Проблемы конфигураций
- Ад зависимостей - Разрастание графа взаимных зависимостей программных продуктов и библиотек, приводящее к сложности установки новых и удаления старых продуктов;
- Вендорный король - архитектура строится от возможностей вендора.

## Неудачные Архитетурные шаблоны в разрезе эволюционности
- Неструктурированный монолит;
- Большой комок грязи;
- Слоистая архитектура (инкрементальные изменения – зависит от правильной грануляции компонентов внутри).

## Удачные Архитектуры
- Модульный монолит;
- Микроядро (плагинная);
- Event-Driven;
- Микросервисы;
- Serverless архитектуры (services, API-gateway).

## Проблемы грануляции
`Основная проблема, которую нужно решить, чтобы сделать хороший софт`

_Как разделить приложение так, чтобы можно было двигаться вперед внося небольшие, «подъемные» изменения, с другой не упасть в антипаттерны (ад зависимостей, копи-паст и т.д.)_

Это оптимально разделение на модули или компоненты. При этом грануляция отвечает на вопрос атомарности (нахождения функционально неделимых компонентов, которые порождают новую функциональность путем комбинирования атомов друг с другом):

- Модули – логическое разделение
- Компоненты – физическое (компонент – это как правило класс в ООП, либо композиция классов). Один из вариантов компонента – сервис, библиотека.

### Что работает плохо, особенно когда нет опыта
- Принцип единственная ответственность – это принцип помогает бороться с желанием укрупнять и делать God-компоненты, но не мешает чрезмерному уменьшению компонентов;
- Принцип подстановки Барбары Лисков - очень часто не до конца понимается этот принцип, поэтому использую только в простейшей форме – если можно подставить родителя самого верхнего уровня, то все ок;
- Принцип открытости/закрытости, так как часто нарушается, очень трудно реализуется на практике, в итоге приводит к «copy/paste» или «два тоннеля».

### Что работает хорошо
- Зацепление и связанность – два принципа, которые четко позволяют понять оптимальный уровень грануляции приложения;
- Программирование в соответствии с интерфейсом – ведение минималистичных интерфейсов, которые на старте содержат 2-3 метода, опять же комбинаторная сложность. _Именно ограничение связей и публичных методов, позволяет очень продвинуть эволюционность, но важно понимать, что уровень грануляции проекта меняется с течением времени и развития проекта. На поздних стадиях, минималистичным можно вполне считать интерфейсы с 5-7 методами, но при этом важно уменьшать комбинаторную сложность_

## Решение в эволюционном стиле

Архитектура любого приложения - это рассмотрение задачи с разных углов зрения и определение возможностей̆ софта. Дополнительные направления для анализа эволюционности (кроме уровня кода, рассмотренного выше): - Техника/инфраструктура - Данные - Безопасность - Интеграции/системы

**Закон Мелвина Конвея**: "Организации, которые проектируют системы, склонны воспроизводить архитектуру которая воспроизводит организационную структуру самой организации"

### Мониторинг
Если вы что-то не можете посчитать, значит вы это не можете контролировать. Значение мониторинга так же важно, как и в микросервисной архитектуре

Основа – фитнес функции, могут быть как автоматизированными, так и организационными.

## Фитнес функции
Это любая оценка, которая позволяет сделать вывод о достижении или приближении к цели проектирования.

Целью проектирования могут выступать любые требования, которые были получены как от заказчика, так и те которые являются следствием проектирования. Мы можем сделать фитнес функцию в виде:

- автоматизированного теста;
- в виде инструкции для человека, который будет вручную проверять наличие необходимых свойств у системы.

`Важно чтобы фитнес функции максимально автоматизировались`

Например, если мы определим требование производительности для выполнения набора операций, скажем 100мс на операцию, то мы можем написать небольшую функцию или программу, которая будет контролировать данный показатель и будет фитнес функция.

### Виды
- атомарные/целостные;
- непрерывные/прерывающиеся;
- статические/динамические;
- автоматизированные/ручные;
- временные;
- ...

### По назначению
- ключевые;
- релевантные/нерелевантные.

## Инкрементальные изменения
Это основной механизм эволюционной архитектуры. Идея в том, чтобы двигаться вперед небольшими шагами, заменяя устаревшие компоненты более новыми аналогами. Небольшим изменение может оставаться только до тех пор пока оно самодостаточно, не имеет лишних связей и не решает глобальных проблем. После каждого изменения должен идти этап развертывания.


`Основа эволюционной архитектуры - непрерывное развертывание`

## Модульность
В основе модульности лежит идея слабого зацепления и автономность модулей. Иерархия стандартная: модуль - компонент - код.

### Процесс
1. инкрементальные изменения;
2. построение и поддержание фитнес функций;
3. поддержание модульности и управление связями.

### Алгоритм построения эволюционной архитектуры
1. Определить требования, которые защищены эволюцией; 
2. Определить фитнес функции (оценки качества) для фич и требований; 
3. Настроить мониторинг; 
4. Настроить непрерывное развертывание с учетом автоматизации фитнес функций (конвейер; развертывания); 
5. Движение вперед по процессу описанному выше, т.е. для каждой новой фичи определяются; изменения, новые или существующие фитнес функции, в рамках внедрения контролируются связи (!).

## Основные проблемы
![img.png](img.png)