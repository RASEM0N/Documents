# Компонентно ориентированная декомпозиция 
это часть процесса построения архитектуры приложения, в задачи которой входит уменьшение зацепления компонентов между собой, в некоторых случаях для этого требуется изменение компонентной структуры приложения. 

[SOER.pro](https://platform.soer.pro/#!/pages/streams/kinescope/23b14e27-89d5-4e4b-a699-420e576a9b92)

## Подходы уменьшения зацепления
- извлечение компонента - извлекаем точечно компонент (класс) из зависимостей и "оборачиваем" интерфейсом; 
- дублирование компонентов - копируем модуль, очищаем только нужное и связаваем с "старым" модулем.

## Алгоритм уход от плохой монолитной архитектуры

### Основные шаги (переход на модульный монолит)
- оптимизировать наиболее загруженные места в коде (+ техдолг);
- определение силы зацепления (диаграмму туже построить);
- проведение архитектурных границ - выделение модулей;

_гораздо лучше перестроить архитектуру по частам, чем рядом построить новую, ибо это дешевле и легче, при таком походе будет Франкиншейт первое время, но потом все улажится. Так что декомпозиция эффективнее_

### Дополнительные шаги (уже дальше монолита можно идти)
- повышение уровня абстракций интерфейсов;
- выделение доменов;
- переход на модульную компонентную основу.

## Отличие "Архитектуры" от "Декомпозиции"
Декомпозиции - это разделение целого на части. Разделение проблем на множество частных проблем, с помощью решений которых, можно сформировать решение исходной проблемы в целом

Архитектура - это выделение главного и принятие решений о функционировании системы в целом:

- выбор структуры элеменов и их интерфейсов, взаимодействие их между собой;
- соеденине элементов в более крупные системы;
- архитектурный стиль, который направляет всю организацию — все элементы, их интерфейсы, их сотрудничество и их соединение.

### Процесс выработки архитектурных решений
- формулирование требований (ограничения, свойства и т.д.);
- анализ и выработка "правил" функционирования программной системы (общие архитектурные решения, которые помогают принимать решение при написании кода или построении архитектурных представлений);
- подготовка архитектурных представлений (как правило графическая декомпозиция системы на графические представления, разделенные на уровни абстракции);
- анализ конечных свойств системы (проверка на соответствие требования и ограничениям).


### Вывод
Таким образом "декомпозиция" действительно используется как составной компонент построения архитектуры программной системы, но само понятие архитектуры гораздо шире, чем само понятие декомпозиции. Так же важно понимать, что архитектурная декомпозиция строится как правило на базе функциональной декомпозиции, а не модульной или классовой.


## Оптимизация кодов базы
Впервую очередь надо понять размер Техдолга и качество построенной архитектуры. Самое простое, что можно сделать для оценки качества архитектуры - построить "температурную карту приложения".

Температурная карта - это схематическое отображение компонентов приложения в виде прямоугольник окрашенных в градацию цвета от зеленого до красного. При этом:

- размер прямоугольника определяется количеством строк в компоненте; 
- температура (цвет) определяется по метрикам оценки "Модифицируемости компонента":
    - цикломатической сложность; 
    - глубина наследования; 
    - количество условных выражений;

### Шаги
1. визуализировать приложение с позиции качеств кода;
2. выделить наиболее и наименее перегруженные места. 
3. Понять насколько сбалансирован код, в контексте модифицируемости.

[SonarQube: делаем код лучше](https://habr.com/ru/companies/sportmaster_lab/articles/746320/)


## Определение силы зацепления
После оптимизации кодовой базы у нас получается монолитная система с более удачным уровнем грануляции компонент, сбалансированных по сложности и размеру, но остается примерной такой же уровень зацепления, который и был.

`2-3 зацепления - ОК, более 7 - ПЛОХО`

### Шаги
1. Выявить компоненты с наибольшим уровнем зацепления;
2. Оптимизировать зацепление/

### Способы оптимизации зацепления
1. Уменьшения силы связи;
2. Разнесения обязанностей;
3. Выделение переиспользуемого кода;
4. Использовать принципы DI (Dependency Injection).

## Проведение архитектурных границ
После того, как выполнены предыдущие два шага, у нас получается хорошо спроектированное монолитное приложение, которое не имеет явных проблем с основными характеристиками качества. На следующем этапе необходимо провести четкие архитектурные границы (частично они уже есть, но теперь их нужно провести явно).

## Шаги
1. Провести архитектурные границы, изолирующие функциональность приложения;
2. Объединить компоненты в модули и сформировать четкие интерфейсы взаимодействия;
3. Оформить графическое представление с учетом архитектурных границы (например, используя С4);
4. Определить пространство имен (может проходить по границе модуля).

## Повышение уровня абстракции интерфейсов
Обычно в монолитных приложениях используется прямое обращение ко всем сущностями приложения (например, прямое обращение к методам класса). Исключением, как правило, является обращение к СУБД, которе делается либо через драйвер, либо дополнительно используется прослойка ORM.

### Шаги
Выявить интерфейсы на уровне модулей и поднять их уровень абстракции

**Повышение уровня абстракции интерфейса, как правило, достигается за счет перехода от интерактивных механизмов взаимодействия к реактивным. Наиболее популярен механизм "Pub/Sub", где есть источник, приемник и медиатор (шина). Для использование интерфейса унифицируется формат передачи данных и способы сериализации данных (бинарные или текстовые).**


## ... дальше уже для сервисной и микросервисной архитектуры идет