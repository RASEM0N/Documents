GRASP (общие паттерны распределения обязанностей) – это набор принципов проектирования по версии Крэга Лармана.

https://www.youtube.com/watch?v=Kp1nfw0LDXc  
https://www.youtube.com/watch?v=8wRQ92Hg2bY


### Принципы
_Прицнипы которыми должен обладать класс_

#### Полиморфизм
Позволяет обрабатывать альтернативные поведения на основе типа, заменять подключаемые компоненты системы.

_Все альтернативные реализации приводятся к общему интерфейсу_

#### Низкая зацепленность
Если объекты в приложении сильно связаны, то любое изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает баги.

_Программируйте на основе абстракций (интерфейс, абстрактный класс и т.п.), а не реализаций._

#### Высокая связность
Относится к **Низкой зацепленности**, они идут в паре и одно всегда приводит к другому. Класс должен иметь какую-то одну ответственность.

_Программируйте так, чтобы один класс имел единственную зону ответственности, и, следовательно, был сильно сцеплен внутри._

#### Устойчивый к изменениям
Определите точки прогнозируемого изменения или нестабильности, распределите обязанности по созданию стабильного интерфейса вокруг них.

_Необходимо обеспечить устойчивость интерфейса. Если будет много изменений связанных с объектом, он считается не устойчивым, тогда его нужно выносить в абстракцию, от которой он будет зависеть._

### Паттерны, отвечающие принципап
_Определенный класс должен быть одним из них_

#### Информационный экспект (Model)
Основная идея этой роли заключается в следующей фразе «решение должно
приниматься в том месте, где содержится наибольшее количество информации, для
принятия решения»..

Или, другими словами, если в классе содержится информация необходимая для
проведения расчета, то и расчет должен производиться в этом классе. Следствием
является то, что при проведении рефакторинга «извлечение метода», вместо с методом
должны быть извлечены и свойства класса, необходимые методу.

Применение этой роли устанавливает связь между данными и методами их
обрабатывающими.

```c#
public class Customer
{
   private readonly List<Order> _orders = new List<Order>();

   public decimal GetTotalAmount(Guid orderId)
   {
       return this._orders.Sum(x => x.Amount);
   }
}
```

#### Создатель (Фабричный метод, Абстрактная фабрика)
Суть ответственности такого объекта в том, что он создает другие объекты. 

По сути шаблон проектирования Абстрактная фабрика (создание объектов концентрируется в отдельном классе) это альтернатива создателя.

#### Контроллен (Controller)
Основная идея заключается в том, что в любой программе есть необходимость реагировать на внешние события, такие как действие пользователей или сообщения,
полученные от операционной системы и т.д. В таких случаях ответственность за обработку таких событий должна находиться в одном месте и реализовываться в рамах роли «Контроллер».

При назначении обязанностей, связанных с данной ролью, необходимо помнить о принципе «сильная связность» и не совмещать в одном классе обработку событий разных типов или уровней абстракции.

#### Чистая выдумка (Service)
Какую проблему решает Pure Fabrication?
- Уменьшает зацепление;
- Повышает связность;
- Упрощает повторное использование кода.

К примеру у вас есть объект Customer и следую шаблону  информационный эксперт вы наделили его логикой которую мы показывали выше, как вы реализуете сохранение Customer-a в БД?

Так вот следуя Pure Fabrication принципу, мы создадим Сервис или репозиторий который будет доставать и сохранять такой объект в базу данных.

#### Посредник
Так как мы живем в постоянно изменяющемся мире, то эти изменения находят свое отражение и в разрабатываемом программного обеспечении, в процессе внесения изменений в программу устанавливаются новые связи между классами, что приводит к нарушению принцип «низкое зацепление»

Для того, чтобы архитектурные границы модулей и классов не менялись, и классы по прежнему могли использоваться максимально независимо друг от друга в программу вносятся сущности с ролью «посредник»

У классов с данной ролью есть одна задача – быть связующим звеном между существующими классами программы. Причем «посредник» должен так же функционировать в рамках существующих интерфейсов, а не реализовывать взаимодействие классов напрямую.

К «посреднику» не предъявляются требования повторного использования и переносимости. Данный код используется в конкретном месте и часто это делается только один раз.

Изменения кода посредника более предпочтительно, чем изменение кода классов, для которых он используется. Поэтому классы с этой ролью могут изменяться чаще и требования к изменениям в части качества кода могут быть ниже.

В виду своей специфической задачи «посредники» не должны содержать бизнес-логики и порой могут не иметь собственного состояния. Так же посредник может быть выполнен в виде обертки над существующими классами, или сторонними библиотеками.