### Книга
Из всех принципов SOLID наиболее трудно понимаемым является принцип единственной ответственности SRP

Услышав это название, многие программисты решают: оно означает, что каждый модуль должен отвечать за что-то одно. Самое интересное, что такой принцип действительно существует. Он гласит: функция должна делать что-то одно и только одно. Этот принцип мы используем, когда делим большие функции на меньшие, то есть на более низком уровне. Но он не является одним из принципов SOLID — это не принцип единственной ответственности.

Традиционно принцип единственной ответственности описывался так: 

`Модуль должен иметь одну и только одну причину для изменения.`

Программное обеспечение изменяется для удовлетворения нужд пользователей и заинтересованных лиц. Пользователи и заинтересованные лица как раз и есть та самая «причина для изменения», о которой говорит принцип. Фактически принцип можно перефразировать так:

`Модуль должен отвечать за одного и только за лицо, желающего изменения`

`модуль — это просто связный набор функций и структур данных`. 
`Слово «связный» (осмысленный) подразумевает принцип единственной ответственности` 
`Связность — это сила, которая связывает код, ответственный за лицо, желающего изменения код`
### Видео

`Никогда не должно быть более одной причины для изменения класса`

`Связность - это SRP, это когда мы собираем вместе все одинаковые обязанности и разделяем разные обязаности`.
`Связность — это сила, которая связывает код, ответственный за единственного актора`

Чем выше Связность, тем ниже Связанность и наоборот.
Связанность показывает насколько модули зависимы от внутреннего устройства друг друга.
#### Подсчет ответственности
- **Оси изменения требований**. Если класс в себе таит логику логирования и кэширования, то уже изменения прейдут с двух сторон
- **Пользователь API - источник потенциальных изменений**. Чем больше его людей разного рода использует тем чаще он будет изменятся
#### Запахи
- Смешивание логики и инфраструктуры
- Класс или модуль обслуживает разные зоны ответственности
#### Паттерны
Применение SRP ведёт к появлению множества маленьких классов
Паттерн "Фасад" в помощь - объединяет функционал требуемый клиента
- Предоставляет упрощенный API для взаимодействия с набором классов
- Предоставляет более чистый API клиенту. Переписывать долго, а хочется хорошечно сделать

#### SRP применим на разных уровнях:
- **Функции**
- **Объект**
- **Модуль**

#### Пример нарушения
```typescript
class PaymentProcessor {

	public charge(amount: number): void {
		// ... инициализурем банк
		// отправляем запрос
	}

	public createReport(): string {
		return 'some report'
	}

	public printReport(): void {
		// ... инициализация принтера
		// отправляем команду на репорт
	}

	public savePayment(): void {
		// сохранение в БД
	}
}
```
##### Проблемы
- Один программист меняет оплату, а другой принтер и бан происходит - в одном классе ковыряются.
- Накопления большого кол-ва ответственности - хуй прочтешь.
- Ответственности смешиваются с друг с другом и становятся связанными.
