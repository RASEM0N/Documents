Фундаментальным понятием, на котором основан обмен сообщениями, является событие — факт удовлетворения некоторого условия, объединенный с определенной контекстной информацией (например, кто, что и когда сделал) и оформленный источником в виде сообщения.

Семантика передачи сообщений не зависит способа их обработки получателем.

### Сообщения и событие
Два способа соединения источников данных с их потребителями:
- события - позволяют привязывать ответы к определенным событиям и следят за тем, чтобы в момент возникновения этих событий выполнялся подходящий код. Каждая такая функция обычно представляет собой небольшую анонимную процедуру, которая реагирует на определенное действие, (например нажатие кнопки мыши. теже callback-и в классах, в View допустим onClick, onMouse)
- сообщения - позволяет отправлять сообщения конкретным адресатам. Вместо анонимных функций обратного вызова используются получатели, которые потребляют сообщения, полученные из потенциально анонимных источников. (тот же eventBus)

Ни источник, ни система в целом не должны заботиться о корректном ответе — для этого существует текущая конфигурация потребителей. (например, если какая-то часть системы сгенерировала журнальное событие, ее не должно интересовать, как оно будет потребляться).

Потребитель ответственен за обработку собственных входящих сообщений, дает несколько преимуществ:
- Обработка может выполняться последовательно для отдельных источников, что позволяет хранить состояние, не требуя синхронизации;
- Последовательная обработка позволяет реагировать на событие в зависимости от текущего состояния потребителя;
- Когда система перегружена, потребители могут игнорировать события или упрощать их обработку;
- Последним, но немаловажным преимуществом является то, что такой подход применяется и самими людьми — в том смысле, что мы тоже выполняем просьбы сослуживцев последовательно.

_Сходство между обменом сообщениями и взаимодействием между людьми не ограничивается последовательной обработкой. Мы не читаем чужие мысли и не выражаем их телепатически, а обмениваемся словами: разговариваем, пишем записки и т. д. Тот же принцип воплощен и в архитектуре программного обеспечения в виде инкапсулированных объектов, которые взаимодействуют путем передачи сообщений._

### Асинхронность и синхронность
Источник может связаться с потребителем двумя способами:
- синхронно, когда обе стороны должны быть готовы к взаимодействию в одно и то же время;
- асинхронно, когда сообщения отправляются независимо от того, готова ли принимающая сторона.

Превосходство асинхронной передачи сообщений становится очевидней, когда получателей несколько. Было бы крайне неэффективно ждать, когда все получатели будут готовы к взаимодействию, или даже просто передавать сообщения по очереди.

Асинхронный обмен сообщениями означает, что получатель рано или поздно узнает о новом входящем сообщении и обработает его сразу, как только это будет целесообразно. Получателя можно оповестить двумя способами:
- можно зарегистрировать функцию обратного вызова, описывающую, что должно произойти в случае определенного события;
- можно принимать сообщения в «почтовый ящик» (очередь) и затем уже отдельно решать, что делать с каждым из них.

### Управление потоком

Управление потоком — это процесс, корректирующий частоту передачи потока сообщений для того, чтобы не переполнить принимающую сторону.

### Синхронный обмен сообщениями